#+TITLE: Vulkan Notes
#+STARTUP: overview

* Glfw
  * re-sizable isn't straightforward.
  * disable GL api call

* Instance
1. Connection between application and vulkan library.
2. Reveals application details to the driver.
3. =VkInstance=:
   - Write note about it.
     * So far, is a object of type instance.
4. =VkApplicationInfo=
   * Data about the application
   * Optional data.
   * Useful for optimization.
   * The =sType= is specified explicitly.
   * =pNext= is a pointer to extension. (Left =nullptr= initially)
5. =VkInstanceCreateInfo=
   * required
   * Tells driver about global extension and validation layers
6. Extension
   * Vulkan requires being explicit about extension for window system.
7. =VkResult=
   * Returned by =vkCreateInstance=.
   * =VK_SUCCESS= or some result.
8. General Pattern for object Creation
   a. Pointer to struct with creation info
   b. Pointer to custom allocator callbacks
   c. Pointer to variable that stores the handle to new object.

** TODO As a challenge, try to create a function that checks if all of the extensions returned by =glfwGetRequiredInstanceExtensions= are included in the supported extensions list.
* Validation Layer
- The driver doesn't care about resources and type errors. Therefore, everything boils down to the programmer for correct behavior.
- These features gets hooked into function calls with intent to apply additional operations.
- Logging, Resource Leakage, Sanitization, Profiling, Replaying, Checking threads etc.
- Only available with Vulkan SDK
- Types:
  * Instance specific (Applied to Vulkan calls)
  * Device specific (Deprecated)
** Using it
1. Given by standard SDK.
2. Using =vkEnumerateInstanceLayerProperties= identical to =vkEnumerateInstanceExtensionProperties=, list the available layers
** Message Callback
- The error messages can be explicitly handled.
- Allows to fine tune with the error message. Good for making decisions early on.
- Add debug utils extension on the vulkan.
*** Creating a debug call function.
- =VKAPI_ATTR= and =VKAPI_CALL= are there to ensure the correct function signature.
- Severity Flags:
  * =VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT=: Diagnostic message
  * =VK_DEBUG_UTILS_MESSAGE_SEVERITY_INFO_BIT_EXT=: Informational message like the creation of a resource
  * =VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT=: Message about behavior that is not necessarily an error, but very likely a bug in your application
  * =VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT=: Message about behavior that is invalid and may cause crashes
- Message Types
  * =VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT=: Some event has happened that is unrelated to the specification or performance
  * =VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT=: Something has happened that violates the specification or indicates a possible mistake
  * =VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT=: Potential non-optimal use of Vulkan
- Callback Data
  * =pMessage=: The debug message as a null-terminated string
  * =pObjects=: Array of Vulkan object handles related to the message
  * =objectCount=: Number of objects in array
*** Creating debug extension
- This doesn't get loaded by default.
- Therefore manual search is necessary. Do it using =vkGetInstanceProcAddr=
- Create it and call the function
- The message extension must be destroyed before destroying the instance.
- Understand what it means to separate these things.
** More information on: vulkan sdk/config/vk_layer_settings.txt
* Physical device
** Select the graphics
- There are wide features available in the vulkan library. Therefore it is
  required to select the appropriate graphics cards.
** Usage
1. Tutorial assumes to use only single graphics card, but multiple can be used
   simultaneously.
2. Destroy a physical device handle when the instance is deleted.
** Picking a device
1. Enumerate the available devices using =vkEnumeratePhysicalDevices=.
2. Exit the process if no device is available.
3. Hold the device handles and check if the  device is suitable.
4. If it is suitable pick it.
5. If there aren't any device, we throw error.
** Checking if a device is suitable.
1. We can query for the device properties using =vkGetPhysicalDeviceProperties=.
2. In case we want a GPU to have a geometry shader, we can if the property is
   present or not.
   #+begin_src cpp
  bool isSuitableExample(const VkPhysicalDevice &device) {
    // This can include complex logics. For this tutorial we return true as soon
    // as we get a device.
    VkPhysicalDeviceProperties props;
    VkPhysicalDeviceFeatures feats;

    vkGetPhysicalDeviceProperties(device, &props);
    vkGetPhysicalDeviceFeatures(device, &feats);

    return props.deviceType == VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU ||
           feats.geometryShader;
  }
   #+end_src
3. Another way is to create a rating system that attaches the score based on the
   available features. This is useful when considering how to handle the devices.
** Queue Families
1. Each queue allows only a subset of commands.
2. Therefore we need to check the type of queues supported by device and
   as per our requirement.
3. Query the queue family properties and then select the queue that supports
   graphics bit.
* Logical Device
 1. Start by creating a =VkDevice=
** Initialize =VkDeviceQueueCreateInfo=
1. As with physical device, one has to decide the queue type for this device too.
   This queue info belongs to the actual physical device.
2. We do not need more queues: Reason command buffers, multiple threads and synchronize.
3. However we can influence the scheduling in the queues.
4. Required even for single queue. $0.0 \leq \text{priority} \leq 1.0$.
** Select physical device features =VkPhysicalDeviceFeatures=
1. Once features are ready, we are going to select features. (In tutorial at this stage it is false. )
*** Updates:
** Finally create logical device:
1. Use =VkDeviceCreateInfo=
2. There are certain compatibility factors. Those are ignored.
3. To create pass it requires physical device, create info and the logical device.
** When exiting, delete the device.
** Queue
When vulkan creates logical device, a queue is also created. But there won't be interface to access it. Therefore, remember to create the interface.

* Window surface
** Surface Creation
Use =glfwCreateWindowSruface= to create platform agnostic surface. Surfaces are generally created after messages.
** Presentation support
1. Not all device may be suitable for presentation. Therefore, only take devices that can present.
2. There can be different queue family to support for drawing commands and support for presentation commands.
3. Therefore, device creation should check for the presentation support too.
4. It can happen that both of the queue may end up being same.
** Presentation Queue
1. Logical device will need a presentation queue.
2. Easy way is to use a set to create the queue.
3. Once we have the set, we iterate through the set and create multiple queue info.
* Swap Chain
1. Without default framebuffer, it is our responsibility to create buffers that can render our data.
2. /Swap Chain/ handles this infrastructure.
3. Queue of images waiting to pop up on screen.
4. Synchronize presentation of images with refresh rate.
** Check swap chain
1. Vulkan core doesn't support swap chain. It comes from extension.
2. Therefore, device should be able to support the swap chain.
3. First check if the device supports the swap chain extension or not!
4. Having a presentation queue => swap chain must be supported.
5. This two time checking is a good to have stuff.
** Making swap chain work at it's best.
1. Checking if swap-chain is available isn't sufficient.
2. It required details
   - Basic surface capabilities
   - Surface formats
   - Available present mode.
** =VkSurfaceCapabilitiesKHR=
1. Querying functions have =VkPhysicalDevice= and =VkSurfaceKHR=. (Core part of swap chain)
2. Notice that vulkan has this thing of doing two function calls. First to get the count and second to fill the list. This is used for knowing the format.
3. Once all the details are fetch, make sure the device is suitable
** Choosing right settings.
1. There are can different color depth, presentation mode and resolution of image in swap chain.
*** Surface Format
#+begin_src C
struct VkSurfaceFormatKHR {
  VkFormat format; // Specifies color channels and types
  VkColorSpaceKHR colorSpace; // Indicates if SRGB space is supported or not.
};
#+end_src
*** Presentation Mode;
1. It is important because contents are shown here.
1. Possible modes:
   i. =VK_PRESENT_MODE_IMMEDIATE_KHR=: directly to screen.
   i. =VK_PRESENT_MODE_FIFO_KHR=: A queue. Display takes an image from front of queue and program inserts rendered image back on the queue. /vertical blank/ = refresh the display.
   i. =VK_PRESENT_MODE_FIFO_RELAXED_KHR=:
   i. =VK_PRESENT_MODE_MAILBOX_KHR=:
*** Swap extent.
1. Resolution of swap chain.
2. Almost equal to window res.
3. Match resolution of window setting width/height.
4. Pick resolution that matches =minImageExtent= and =maxImageExtent= bounds.
5. Vulkan uses pixels and screen coordinates.
** Creating Swap chain
1. Select all the parameters above.
2. Determine number of images in swap chain.
3. =imageArrayLayers= specifies amount of layers each image consists.
4. =imageUsage= specifies kind of operations in swap chain.  This is where you can render to different places for post processing.
5. Specify how to handle swap chains.
   - =VK_SHARING_MODE_EXCLUSIVE=: one queue family owns one image. Best perf.
   - =VK_SHARING_MODE_CONCURRENT=: Across multiple queues without ownership.
     Concurrent mode requires to specify in advance between which queue families ownership will be shared using the =queueFamilyIndexCount= and =pQueueFamilyIndices= parameters.
6. Swap chain can have different image transforms.
7. =compositeAlpha= specifies alpha blending.
8. =clipped= clips away the information. But can be used in predictive things.
9. =oldSwapChain=: Complex topic.
10. Finally create the swap chain.
** Retriving images.
1. Create a vector of =VkImage= and follow the two function call routine!
* Image Views
1. =VkImage= requires =VkImageView= for rendering. It is an option to view the  image. Describes how the image is accessed and which part of the image to access.
2. Create a vector to hold image views.
3. To create a image view
   - Allocate size of  the =swapChainImagesViews=
   - Then use =VkImageViewCreateInfo=
4. =viewType= specify 1D, 2D, 3D textures or cube map.
5. =components=: Allow to swizzle the images.
6. =subresourceRange= describe the image's purpose and part to access. It can also include mipmaps
 7. Destroy the image views.
* Render pipeline
1. Input assembler
2. Vertex shader
3. Tessellation shader
4. Geometry shader
5. Rasterization
6. Fragment shader
7. Color blending
* Shaders
1. Vulkan requires shader in SPIR-V format.
2. Therefore, it will requires loading a binary.
** Shader Modules
1. =VkShaderModule= wraps shader to pass through the pipeline
2. Creating is simple. Requires pointer to buffer + length
3. Specified in =VkShaderModuleCreateInfo=
3. Shademodules are destroyed at the end of function.
** =VkPipelineShaderStageCreateInfo=
1. It assigns shaders to a pipeline stage .
2. =module= contains the vertex shader module (shader code)
3. =pName= contains the entry to the vertex shader.
4. =pSpecializationInfo= allows specifying constants. Therefore we can create multiple pipelines using same shader module. (helps compiler optimize the stuff.)
