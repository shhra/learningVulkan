#+TITLE: Vulkan Notes
#+STARTUP: overview

* Glfw
  * re-sizable isn't straightforward.
  * disable GL api call

* Instance
1. Connection between application and vulkan library.
2. Reveals application details to the driver.
3. =VkInstance=:
   - Write note about it.
     * So far, is a object of type instance.
4. =VkApplicationInfo=
   * Data about the application
   * Optional data.
   * Useful for optimization.
   * The =sType= is specified explicitly.
   * =pNext= is a pointer to extension. (Left =nullptr= initially)
5. =VkInstanceCreateInfo=
   * required
   * Tells driver about global extension and validation layers
6. Extension
   * Vulkan requires being explicit about extension for window system.
7. =VkResult=
   * Returned by =vkCreateInstance=.
   * =VK_SUCCESS= or some result.
8. General Pattern for object Creation
   a. Pointer to struct with creation info
   b. Pointer to custom allocator callbacks
   c. Pointer to variable that stores the handle to new object.

** TODO As a challenge, try to create a function that checks if all of the extensions returned by =glfwGetRequiredInstanceExtensions= are included in the supported extensions list.
* Validation Layer
- The driver doesn't care about resources and type errors. Therefore, everything boils down to the programmer for correct behavior.
- These features gets hooked into function calls with intent to apply additional operations.
- Logging, Resource Leakage, Sanitization, Profiling, Replaying, Checking threads etc.
- Only available with Vulkan SDK
- Types:
  * Instance specific (Applied to Vulkan calls)
  * Device specific (Deprecated)
** Using it
1. Given by standard SDK.
2. Using =vkEnumerateInstanceLayerProperties= identical to =vkEnumerateInstanceExtensionProperties=, list the available layers
** Message Callback
- The error messages can be explicitly handled.
- Allows to fine tune with the error message. Good for making decisions early on.
- Add debug utils extension on the vulkan.
*** Creating a debug call function.
- =VKAPI_ATTR= and =VKAPI_CALL= are there to ensure the correct function signature.
- Severity Flags:
  * =VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT=: Diagnostic message
  * =VK_DEBUG_UTILS_MESSAGE_SEVERITY_INFO_BIT_EXT=: Informational message like the creation of a resource
  * =VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT=: Message about behavior that is not necessarily an error, but very likely a bug in your application
  * =VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT=: Message about behavior that is invalid and may cause crashes
- Message Types
  * =VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT=: Some event has happened that is unrelated to the specification or performance
  * =VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT=: Something has happened that violates the specification or indicates a possible mistake
  * =VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT=: Potential non-optimal use of Vulkan
- Callback Data
  * =pMessage=: The debug message as a null-terminated string
  * =pObjects=: Array of Vulkan object handles related to the message
  * =objectCount=: Number of objects in array
*** Creating debug extension
- This doesn't get loaded by default.
- Therefore manual search is necessary. Do it using =vkGetInstanceProcAddr=
- Create it and call the function
- The message extension must be destroyed before destroying the instance.
- Understand what it means to separate these things.
** More information on: vulkan sdk/config/vk_layer_settings.txt
* Physical device
** Select the graphics
- There are wide features available in the vulkan library. Therefore it is
  required to select the appropriate graphics cards.
** Usage
1. Tutorial assumes to use only single graphics card, but multiple can be used
   simultaneously.
2. Destroy a physical device handle when the instance is deleted.
** Picking a device
1. Enumerate the available devices using =vkEnumeratePhysicalDevices=.
2. Exit the process if no device is available.
3. Hold the device handles and check if the  device is suitable.
4. If it is suitable pick it.
5. If there aren't any device, we throw error.
** Checking if a device is suitable.
1. We can query for the device properties using =vkGetPhysicalDeviceProperties=.
2. In case we want a GPU to have a geometry shader, we can if the property is
   present or not.
   #+begin_src cpp
  bool isSuitableExample(const VkPhysicalDevice &device) {
    // This can include complex logics. For this tutorial we return true as soon
    // as we get a device.
    VkPhysicalDeviceProperties props;
    VkPhysicalDeviceFeatures feats;

    vkGetPhysicalDeviceProperties(device, &props);
    vkGetPhysicalDeviceFeatures(device, &feats);

    return props.deviceType == VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU ||
           feats.geometryShader;
  }
   #+end_src
3. Another way is to create a rating system that attaches the score based on the
   available features. This is useful when considering how to handle the devices.
** Queue Families
1. Each queue allows only a subset of commands.
2. Therefore we need to check the type of queues supported by device and
   as per our requirement.
3. Query the queue family properties and then select the queue that supports
   graphics bit.
* Logical Device
 1. Start by creating a =VkDevice=
** Initialize =VkDeviceQueueCreateInfo=
1. As with physical device, one has to decide the queue type for this device too.
   This queue info belongs to the actual physical device.
2. We do not need more queues: Reason command buffers, multiple threads and synchronize.
3. However we can influence the scheduling in the queues.
4. Required even for single queue. $0.0 \leq \text{priority} \leq 1.0$.
** Select physical device features =VkPhysicalDeviceFeatures=
1. Once features are ready, we are going to select features. (In tutorial at this stage it is false. )
*** Updates:
** Finally create logical device:
1. Use =VkDeviceCreateInfo=
2. There are certain compatibility factors. Those are ignored.
3. To create pass it requires physical device, create info and the logical device.
** When exiting, delete the device.
** Queue
When vulkan creates logical device, a queue is also created. But there won't be interface to access it. Therefore, remember to create the interface.
