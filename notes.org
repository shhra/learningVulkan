#+TITLE: Vulkan Notes
#+STARTUP: overview

* Glfw
  * re-sizable isn't straightforward.
  * disable GL api call

* Instance
1. Connection between application and vulkan library.
2. Reveals application details to the driver.
3. =VkInstance=:
   - Write note about it.
     * So far, is a object of type instance.
4. =VkApplicationInfo=
   * Data about the application
   * Optional data.
   * Useful for optimization.
   * The =sType= is specified explicitly.
   * =pNext= is a pointer to extension. (Left =nullptr= initially)
5. =VkInstanceCreateInfo=
   * required
   * Tells driver about global extension and validation layers
6. Extension
   * Vulkan requires being explicit about extension for window system.
7. =VkResult=
   * Returned by =vkCreateInstance=.
   * =VK_SUCCESS= or some result.
8. General Pattern for object Creation
   a. Pointer to struct with creation info
   b. Pointer to custom allocator callbacks
   c. Pointer to variable that stores the handle to new object.

** TODO As a challenge, try to create a function that checks if all of the extensions returned by =glfwGetRequiredInstanceExtensions= are included in the supported extensions list.
* Validation Layer
- The driver doesn't care about resources and type errors. Therefore, everything boils down to the programmer for correct behavior.
- These features gets hooked into function calls with intent to apply additional operations.
- Logging, Resource Leakage, Sanitization, Profiling, Replaying, Checking threads etc.
- Only available with Vulkan SDK
- Types:
  * Instance specific (Applied to Vulkan calls)
  * Device specific (Deprecated)
** Using it
1. Given by standard SDK.
2. Using =vkEnumerateInstanceLayerProperties= identical to =vkEnumerateInstanceExtensionProperties=, list the available layers
** Message Callback
- The error messages can be explicitly handled.
- Allows to fine tune with the error message. Good for making decisions early on.
- Add debug utils extension on the vulkan.
*** Creating a debug call function.
- =VKAPI_ATTR= and =VKAPI_CALL= are there to ensure the correct function signature.
- Severity Flags:
  * =VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT=: Diagnostic message
  * =VK_DEBUG_UTILS_MESSAGE_SEVERITY_INFO_BIT_EXT=: Informational message like the creation of a resource
  * =VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT=: Message about behavior that is not necessarily an error, but very likely a bug in your application
  * =VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT=: Message about behavior that is invalid and may cause crashes
- Message Types
  * =VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT=: Some event has happened that is unrelated to the specification or performance
  * =VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT=: Something has happened that violates the specification or indicates a possible mistake
  * =VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT=: Potential non-optimal use of Vulkan
- Callback Data
  * =pMessage=: The debug message as a null-terminated string
  * =pObjects=: Array of Vulkan object handles related to the message
  * =objectCount=: Number of objects in array
*** Creating debug extension
- This doesn't get loaded by default.
- Therefore manual search is necessary. Do it using =vkGetInstanceProcAddr=
- Create it and call the function
- The message extension must be destroyed before destroying the instance.
- Understand what it means to separate these things.
** More information on: vulkan sdk/config/vk_layer_settings.txt
* Physical device
** Select the graphics
- There are wide features available in the vulkan library. Therefore it is
  required to select the appropriate graphics cards.
** Usage
1. Tutorial assumes to use only single graphics card, but multiple can be used
   simultaneously.
2. Destroy a physical device handle when the instance is deleted.
** Picking a device
1. Enumerate the available devices using =vkEnumeratePhysicalDevices=.
2. Exit the process if no device is available.
3. Hold the device handles and check if the  device is suitable.
4. If it is suitable pick it.
5. If there aren't any device, we throw error.
** Checking if a device is suitable.
1. We can query for the device properties using =vkGetPhysicalDeviceProperties=.
2. In case we want a GPU to have a geometry shader, we can if the property is
   present or not.
   #+begin_src cpp
  bool isSuitableExample(const VkPhysicalDevice &device) {
    // This can include complex logics. For this tutorial we return true as soon
    // as we get a device.
    VkPhysicalDeviceProperties props;
    VkPhysicalDeviceFeatures feats;

    vkGetPhysicalDeviceProperties(device, &props);
    vkGetPhysicalDeviceFeatures(device, &feats);

    return props.deviceType == VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU ||
           feats.geometryShader;
  }
   #+end_src
3. Another way is to create a rating system that attaches the score based on the
   available features. This is useful when considering how to handle the devices.
** Queue Families
1. Each queue allows only a subset of commands.
2. Therefore we need to check the type of queues supported by device and
   as per our requirement.
3. Query the queue family properties and then select the queue that supports
   graphics bit.
* Logical Device
 1. Start by creating a =VkDevice=
** Initialize =VkDeviceQueueCreateInfo=
1. As with physical device, one has to decide the queue type for this device too.
   This queue info belongs to the actual physical device.
2. We do not need more queues: Reason command buffers, multiple threads and synchronize.
3. However we can influence the scheduling in the queues.
4. Required even for single queue. $0.0 \leq \text{priority} \leq 1.0$.
** Select physical device features =VkPhysicalDeviceFeatures=
1. Once features are ready, we are going to select features. (In tutorial at this stage it is false. )
*** Updates:
** Finally create logical device:
1. Use =VkDeviceCreateInfo=
2. There are certain compatibility factors. Those are ignored.
3. To create pass it requires physical device, create info and the logical device.
** When exiting, delete the device.
** Queue
When vulkan creates logical device, a queue is also created. But there won't be interface to access it. Therefore, remember to create the interface.

* Window surface
** Surface Creation
Use =glfwCreateWindowSruface= to create platform agnostic surface. Surfaces are generally created after messages.
** Presentation support
1. Not all device may be suitable for presentation. Therefore, only take devices that can present.
2. There can be different queue family to support for drawing commands and support for presentation commands.
3. Therefore, device creation should check for the presentation support too.
4. It can happen that both of the queue may end up being same.
** Presentation Queue
1. Logical device will need a presentation queue.
2. Easy way is to use a set to create the queue.
3. Once we have the set, we iterate through the set and create multiple queue info.
* Swap Chain
1. Without default framebuffer, it is our responsibility to create buffers that can render our data.
2. /Swap Chain/ handles this infrastructure.
3. Queue of images waiting to pop up on screen.
4. Synchronize presentation of images with refresh rate.
** Check swap chain
1. Vulkan core doesn't support swap chain. It comes from extension.
2. Therefore, device should be able to support the swap chain.
3. First check if the device supports the swap chain extension or not!
4. Having a presentation queue => swap chain must be supported.
5. This two time checking is a good to have stuff.
** Making swap chain work at it's best.
1. Checking if swap-chain is available isn't sufficient.
2. It required details
   - Basic surface capabilities
   - Surface formats
   - Available present mode.
** =VkSurfaceCapabilitiesKHR=
1. Querying functions have =VkPhysicalDevice= and =VkSurfaceKHR=. (Core part of swap chain)
2. Notice that vulkan has this thing of doing two function calls. First to get the count and second to fill the list. This is used for knowing the format.
3. Once all the details are fetch, make sure the device is suitable
** Choosing right settings.
1. There are can different color depth, presentation mode and resolution of image in swap chain.
*** Surface Format
#+begin_src C
struct VkSurfaceFormatKHR {
  VkFormat format; // Specifies color channels and types
  VkColorSpaceKHR colorSpace; // Indicates if SRGB space is supported or not.
};
#+end_src
*** Presentation Mode;
1. It is important because contents are shown here.
1. Possible modes:
   i. =VK_PRESENT_MODE_IMMEDIATE_KHR=: directly to screen.
   i. =VK_PRESENT_MODE_FIFO_KHR=: A queue. Display takes an image from front of queue and program inserts rendered image back on the queue. /vertical blank/ = refresh the display.
   i. =VK_PRESENT_MODE_FIFO_RELAXED_KHR=:
   i. =VK_PRESENT_MODE_MAILBOX_KHR=:
*** Swap extent.
1. Resolution of swap chain.
2. Almost equal to window res.
3. Match resolution of window setting width/height.
4. Pick resolution that matches =minImageExtent= and =maxImageExtent= bounds.
5. Vulkan uses pixels and screen coordinates.
** Creating Swap chain
1. Select all the parameters above.
2. Determine number of images in swap chain.
3. =imageArrayLayers= specifies amount of layers each image consists.
4. =imageUsage= specifies kind of operations in swap chain.  This is where you can render to different places for post processing.
5. Specify how to handle swap chains.
   - =VK_SHARING_MODE_EXCLUSIVE=: one queue family owns one image. Best perf.
   - =VK_SHARING_MODE_CONCURRENT=: Across multiple queues without ownership.
     Concurrent mode requires to specify in advance between which queue families ownership will be shared using the =queueFamilyIndexCount= and =pQueueFamilyIndices= parameters.
6. Swap chain can have different image transforms.
7. =compositeAlpha= specifies alpha blending.
8. =clipped= clips away the information. But can be used in predictive things.
9. =oldSwapChain=: Complex topic.
10. Finally create the swap chain.
** Retriving images.
1. Create a vector of =VkImage= and follow the two function call routine!
* Image Views
1. =VkImage= requires =VkImageView= for rendering. It is an option to view the  image. Describes how the image is accessed and which part of the image to access.
2. Create a vector to hold image views.
3. To create a image view
   - Allocate size of  the =swapChainImagesViews=
   - Then use =VkImageViewCreateInfo=
4. =viewType= specify 1D, 2D, 3D textures or cube map.
5. =components=: Allow to swizzle the images.
6. =subresourceRange= describe the image's purpose and part to access. It can also include mipmaps
 7. Destroy the image views.
* Render pipeline
1. Input assembler
2. Vertex shader
3. Tessellation shader
4. Geometry shader
5. Rasterization
6. Fragment shader
7. Color blending
* Shaders
1. Vulkan requires shader in SPIR-V format.
2. Therefore, it will requires loading a binary.
** Shader Modules
1. =VkShaderModule= wraps shader to pass through the pipeline
2. Creating is simple. Requires pointer to buffer + length
3. Specified in =VkShaderModuleCreateInfo=
3. Shademodules are destroyed at the end of function.
** =VkPipelineShaderStageCreateInfo=
1. It assigns shaders to a pipeline stage .
2. =module= contains the vertex shader module (shader code)
3. =pName= contains the entry to the vertex shader.
4. =pSpecializationInfo= allows specifying constants. Therefore we can create multiple pipelines using same shader module. (helps compiler optimize the stuff.)
* Fixed functions
** Vertex Input
- Use =VkPipelineVertexInputStateCreateInfo= to pass format of vertex data.
- It consists /bindings/: Spacing between data, and type of data (per-vertex/per-instance)
- /Attribute descriptions/: type of attributes passed to vertex shader, binding and offset
- More on it later.
** Input Assembly
- =VkPipelineInputAssemblyStateCreateInfo=
  * Geometry to be drawn
  * Primitive restart? What is it? > allows breaking up the topology in =_STRIP=)
  * Index vs element buffer (same as open gl where we pass the index.)
** Viewports & Scissors
- Region of frame-buffer where output is rendered to. (like GL)
- Scissors define region where pixel will be stored.
- Scissors > Viewport can give full image
- Combine into =VkPipelineViewportStateCreateInfo=
** Rasterizer
- Performs depth testing, face culling and scissor test.
- polygon vs edge.
- =depthClampEnable= = True, fragments are clamped to space between near and far planes. These do not discard them.
- =rasterizerDiscardEnable= allows to discard geometry before it goes to rasterization.
- =polygonMode=: Fill, line, or point
** Multipsampling
- Free antialiasing.
- Occurs along the edge.
** Color blending
- Combine with color in framebuffer
- Mix old + new
- Combine using bit operation
- Tutorial has better method too.
** Dynamic state
- Something can be changed on the fly without creating pipeline
** Pipeline layout
- =uniform= are configured with =VkPipelineLayout=
- uniforms are passed into pipeline layout when creating them.
* Render passes
- Vulkan needs to know about framebuffer attachments.
- These are properties like number of color buffer, depth buffer.
- Sampling properties.
- How to handle contents.
- This exists before GraphicsPipeline.
** Attachment description
- Single color buffer attachment atm.
- =format= should match that of swap chain.
- =loadOp=: Determine what to do with data before rendering
  * =VK_ATTACHMENT_LOAD_OP_LOAD=: Preserve the existing contents of the attachment
  * =VK_ATTACHMENT_LOAD_OP_CLEAR=: Clear the values to a constant at the start
  * =VK_ATTACHMENT_LOAD_OP_DONT_CARE=: Existing contents are undefined; we don't care about them
- =storeOp=: Determine what to do with data after rendering
  * =VK_ATTACHMENT_STORE_OP_STORE=: Rendered contents will be stored in memory and can be read later
  * =VK_ATTACHMENT_STORE_OP_DONT_CARE=: Contents of the framebuffer will be undefined after the rendering operation
- If sentcil buffer isn't useful we can discard it.
- =VkImage= can represent texture and framebuffers
  * =initalLayout= specifies layout before render pass
  * =finalLayout= specifies layout to automatically transition when render pass finishes.
    Depending on the value of these fields, we can get different behaviors.
** Subpasses and attachment References
- Single render pass can have multiple subpasses.
- Subpasses depend upon he content of framebuffers in previous passes.
- Postprocessing are subpasses.
- Subpasses references the attachments which are =VkAttachmentReference=
- =attachment= is the index in attachment description array. One attachment therefore 0.
- =layout= specifies the layout for this subpass.
- Subpass is created using =VkSubpassDescroption=.
- This index is referenced from the fragment shader using =layout(location = 0)=
- There are different attachments that can be referenced.
** Renderpass
- =VkRenderPass= contains the renderpass.
- It is a structure that can be filled with different option.
* Frame Buffers
1. Attachments are bound by wraping into Framebuffers.
2. =VkFrameBuffer= is a framebuffer object that references all of =VkImageView= objects that represent the attachments.
3. The swap chain returns an image for presentation. This image gets attached to framebuffer.
4. Each image will have their own frambuffers? WTH!
5. Creation is easy
   - Requires renderpass
   - Image view as attachments.
   - width and height.
* Command Buffers
Vulkan can collect all the commands in command buffer and launch it together. Allows command rendering in multiple threads.
** Command pools
1. Command pools are required for command buffers.
2. Responsible to manage memory for buffers and command buffers
3. =VkCommandPool= stores the fool
4. Command pool requires knowing the queue indices.
5. it has two parameters =flags= and =queueFamilyIndex=.
   - =VK_COMMAND_POOL_CREATE_TRANSIENT_BIT=: Hint that command buffers are rerecorded with new commands often (may change memory allocation behavior)
   - =VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT=: Allow command buffers to be rerecorded individually, without this flag they all have to be reset together
** Command Buffer allocation
- Automatically freed when pools are destroyed.
- =VkAllocateCommandBuffers= allocates the command buffers.
- =level= specifies if allocated buffers are primary or secondary
  * Primary are submitted for execution and can't be called from other buffers
  * Secondary can't be submitted directly but be called from primary
** Recording Command Buffers
- It writes the command to execute into the command buffer.
- Requires command buffer and index of image at the swap chain
- Start bu creating record.
- Can have:
  * /One time submit/: Command buffer will be recorded after executing once.
  * /render pass continue/: Secondary command buffer within a single render pass
  * /simultaneous use/: Resubmit buffer while pending execution.
** Starting Render pass
- To draw one has to start renderpass.
- renderPassInfo takes renderpass, framebuffer we created for storing swap chain image. It also needs to know the swap chain pixel offsets and extent.
- =vkCmdBeginRenderPass= takes the command buffer and render pass info to create the renders.
- Final command can be two options
  * =VK_SUBPASS_CONTENTS_INLINE=
  * =VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS=
** Drawing commands
- Bind pipeline can take compute pipeline or the graphics pipeline! This means we can do compute in GPU simply by passing a pipeline that is responsible for performing heavy computation.
- Draw is simple. Takes the following parameter.
  * =vertexCount=: Even though we don't have a vertex buffer, we technically still have 3 vertices to draw.
 * =instanceCount=: Used for instanced rendering, use 1 if you're not doing that.
 * =firstVertex=: Used as an offset into the vertex buffer, defines the lowest value of =gl_VertexIndex=.
 * =firstInstance=: Used as an offset for instanced rendering, defines the lowest value of =gl_InstanceIndex=.
* Rendering
